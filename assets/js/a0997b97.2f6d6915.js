"use strict";(self.webpackChunk_docs_gh_pages=self.webpackChunk_docs_gh_pages||[]).push([[114],{8660:function(t,e,n){n.r(e),n.d(e,{frontMatter:function(){return l},contentTitle:function(){return o},metadata:function(){return u},toc:function(){return p},default:function(){return d}});var a=n(4820),r=n(5819),s=(n(3929),n(5242)),i=["components"],l={sidebar_position:2},o="Write first test",u={unversionedId:"getting-started/write-first-test",id:"getting-started/write-first-test",isDocsHomePage:!1,title:"Write first test",description:"In this short tutorial we will write test for following class using Behavioral.",source:"@site/docs/getting-started/write-first-test.md",sourceDirName:"getting-started",slug:"/getting-started/write-first-test",permalink:"/behavioral/docs/getting-started/write-first-test",editUrl:"https://github.com/typedtools/behavioral/edit/docs/gh-pages/docs/getting-started/write-first-test.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Installation",permalink:"/behavioral/docs/getting-started/installation"}},p=[],c={toc:p};function d(t){var e=t.components,n=(0,r.Z)(t,i);return(0,s.kt)("wrapper",(0,a.Z)({},c,n,{components:e,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"write-first-test"},"Write first test"),(0,s.kt)("p",null,"In this short tutorial we will write test for following class using Behavioral."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="Calculator.ts"',title:'"Calculator.ts"'},"export enum Operator {\n  ADD = '+',\n  SUBTRACT = '-',\n  DIVIDE = '/',\n  MULTIPLY = '*',\n}\n\nexport class Calculator {\n  private _expression: (string | number)[] = [0];\n\n  append(part: number | Operator): void {\n    if (typeof part === 'number') {\n      if (typeof this._expression[this._expression.length - 1] === 'number') {\n        this._expression[this._expression.length - 1] = part;\n      } else {\n        this._expression.push(part);\n      }\n    } else {\n      if (typeof this._expression[this._expression.length - 1] === 'string') {\n        this._expression[this._expression.length - 1] = part;\n      } else {\n        this._expression.push(part);\n      }\n    }\n  }\n\n  reset(): void {\n    this._expression = [];\n  }\n\n  get expression(): string {\n    return this._expression.join(' ');\n  }\n\n  get result(): number {\n    return eval(this.expression);\n  }\n}\n")),(0,s.kt)("p",null,"It implements simple calculator. Behavioral requires to define class which will store state of a test."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="CalculatorState.ts"',title:'"CalculatorState.ts"'},"import { State } from '@typedtools/behavioral/decorators';\nimport { Calculator } from './Calculator';\n\n@State()\nexport class CalculatorState {\n  calculator = new Calculator();\n}\n")),(0,s.kt)("p",null,"Provided state class can be injected to handler class. Handlers are classes used to define implementation for gherkin steps. Below is example handler created for ",(0,s.kt)("inlineCode",{parentName:"p"},"Calculator")," class."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-typescript",metastring:'title="CalculatorHandler.ts"',title:'"CalculatorHandler.ts"'},"import { Given, Handler, Param, Then, When } from '@typedtools/behavioral/decorators';\nimport { Operator } from './Calculator';\nimport { CalculatorState } from './CalculatorState';\n\n@Handler()\nexport class CalculatorHandler {\n  /*\n    State object is injected via constructor.\n    There is only one instance of state class per scenario, \n    but each scenario has it's own instance of it.\n  */\n  constructor(\n    private state: CalculatorState,\n  ) {}\n\n  @Given('I start with \"<num>\"')\n  @When('I type \"<num>\"')\n  append(@Param('num') num: number): void {\n    this.state.calculator.append(num);\n  }\n\n  @When('I add \"<num>\"')\n  add(@Param('num') num: number): void {\n    this.state.calculator.append(Operator.ADD);\n    this.state.calculator.append(num);\n  }\n\n  @When('I subtract \"<num>\"')\n  subtract(@Param('num') num: number): void {\n    this.state.calculator.append(Operator.SUBTRACT);\n    this.state.calculator.append(num);\n  }\n\n  @When('I divide by \"<num>\"')\n  divide(@Param('num') num: number): void {\n    this.state.calculator.append(Operator.DIVIDE);\n    this.state.calculator.append(num);\n  }\n\n  @When('I multiply by \"<num>\"')\n  multiply(@Param('num') num: number): void {\n    this.state.calculator.append(Operator.MULTIPLY);\n    this.state.calculator.append(num);\n  }\n\n  @Then('I see \"<value>\" as a result')\n  checkResult(@Param('value') value: number): void {\n    expect(this.state.calculator.result).toBe(value);\n  }\n}\n")),(0,s.kt)("p",null,"As you can see step is defined by wrapping handler class method with one of available decorators ",(0,s.kt)("inlineCode",{parentName:"p"},"Given"),", ",(0,s.kt)("inlineCode",{parentName:"p"},"When")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"Then")," and passing it's template as an argument."),(0,s.kt)("p",null,"You can define multiple steps on single handler method."),(0,s.kt)("p",null,"Now you are ready to write your first scenarios."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-feature",metastring:'title="calculator.feature"',title:'"calculator.feature"'},'@use(./CalculatorHandler.ts:CalculatorHandler)\nFeature: Calculator\n\n  Scenario: Addition\n    When I add "12"\n    Then I see "12" as a result\n\n  Scenario: Subtraction\n    When I subtract "12"\n    Then I see "-12" as a result\n\n  Scenario: Division\n    When I divide by "2"\n    Then I see "0" as a result\n\n  Scenario: Multiply\n    When I multiply by "2"\n    Then I see "0" as a result\n')),(0,s.kt)("p",null,"Now we can run it with ",(0,s.kt)("inlineCode",{parentName:"p"},"jest")," command to see result."))}d.isMDXComponent=!0}}]);